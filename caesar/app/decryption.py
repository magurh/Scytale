from caesar.app.cipher import decrypt
from collections import Counter
import random
import string
import math

# Define expected English letter frequencies
expected_freq = {
    'a': 0.08167, 'b': 0.01492, 'c': 0.02782, 'd': 0.04253, 'e': 0.12702,
    'f': 0.02228, 'g': 0.02015, 'h': 0.06094, 'i': 0.06966, 'j': 0.00153,
    'k': 0.00772, 'l': 0.04025, 'm': 0.02406, 'n': 0.06749, 'o': 0.07507,
    'p': 0.01929, 'q': 0.00095, 'r': 0.05987, 's': 0.06327, 't': 0.09056,
    'u': 0.02758, 'v': 0.00978, 'w': 0.02360, 'x': 0.00150, 'y': 0.01974,
    'z': 0.00074
}

# Common digram frequencies in English
expected_digrams = {
    'th': 0.0356, 'he': 0.0307, 'in': 0.0243, 'er': 0.0205, 'an': 0.0199,
    're': 0.0185, 'on': 0.0171, 'at': 0.0149, 'en': 0.0145, 'nd': 0.0135,
    'ti': 0.0134, 'es': 0.0132, 'or': 0.0128, 'te': 0.0120, 'of': 0.0116,
    'ed': 0.0113, 'is': 0.0113, 'it': 0.0112, 'al': 0.0109, 'ar': 0.0108,
    'st': 0.0108, 'to': 0.0107, 'nt': 0.0106, 'ng': 0.0105, 'se': 0.0104
}


def fitness_score(decrypted_text):
    letter_counts = Counter(decrypted_text.lower())
    total_letters = sum(letter_counts.values())
    letter_freq = {char: (count / total_letters) for char, count in letter_counts.items()}
    score = sum((letter_freq.get(char, 0) - expected_freq.get(char, 0))**2 for char in expected_freq)
    
    digram_counts = Counter(decrypted_text.lower()[i:i+2] for i in range(len(decrypted_text)-1))
    total_digrams = sum(digram_counts.values())
    digram_freq = {char: (count / total_digrams) for char, count in digram_counts.items()}
    score += sum((digram_freq.get(digram, 0) - expected_digrams.get(digram, 0))**2 for digram in expected_digrams)
    
    return score

def simple_frequency_analysis(text):
    # Calculate the frequency of each character in the text
    text_freq = Counter(c for c in text.lower() if c in string.ascii_lowercase)
    
    # Sort characters by frequency in text and expected frequency
    text_freq_sorted = [item[0] for item in text_freq.most_common()]
    expected_freq_sorted = sorted(expected_freq, key=expected_freq.get, reverse=True)
    
    # Create a mapping from the most frequent characters in text to most frequent characters in English
    tentative_key = {}
    for i, char in enumerate(text_freq_sorted):
        tentative_key[char] = expected_freq_sorted[i]
    
    # Ensure all letters are included in the key
    remaining_text_chars = [char for char in string.ascii_lowercase if char not in tentative_key]
    remaining_expected_chars = [char for char in expected_freq_sorted if char not in tentative_key.values()]
    
    for char in remaining_text_chars:
        tentative_key[char] = remaining_expected_chars.pop(0)
    
    # Generate the key
    key = ''.join(tentative_key[char] for char in string.ascii_lowercase)
    
    return key

def swap_random_elements(key):
    key = list(key)
    i, j = random.sample(range(len(key)), 2)
    key[i], key[j] = key[j], key[i]
    return ''.join(key)

def frequency_analysis(text, iterations=1000, temperature=1.0):
    # Start with the key generated by simple frequency analysis
    current_key = simple_frequency_analysis(text)
    current_score = fitness_score(decrypt(text, current_key))
    
    best_key = current_key
    best_score = current_score
    
    for _ in range(iterations):
        new_key = swap_random_elements(current_key)
        new_decrypted_text = decrypt(text, new_key)
        new_score = fitness_score(new_decrypted_text)
        
        if new_score < current_score or math.exp((current_score - new_score) / temperature) > random.random():
            current_key = new_key
            current_score = new_score
            
            if new_score < best_score:
                best_key = new_key
                best_score = new_score
        
        temperature *= 0.99  # Decrease the temperature
    
    return decrypt(text, best_key), best_key
